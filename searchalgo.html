<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />
    <meta name="description" content="" />
    <meta name="author" content="" />
    <title>Resume - Start Bootstrap Theme</title>
    <link rel="icon" type="image/x-icon" href="assets/img/favicon.ico" />
    <!-- Font Awesome icons (free version)-->
    <script src="https://use.fontawesome.com/releases/v6.3.0/js/all.js" crossorigin="anonymous"></script>
    <!-- Google fonts-->
    <link href="https://fonts.googleapis.com/css?family=Saira+Extra+Condensed:500,700" rel="stylesheet"
        type="text/css" />
    <link href="https://fonts.googleapis.com/css?family=Muli:400,400i,800,800i" rel="stylesheet" type="text/css" />
    <!-- Core theme CSS (includes Bootstrap)-->
    <link href="css/styles.css" rel="stylesheet" />
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:ital,wght@0,100;0,300;0,400;0,500;0,700;0,900;1,100;1,300;1,400;1,500;1,700;1,900&display=swap" rel="stylesheet">
  

</head>

<body id="page-top">
  <!-- Navigation-->
  <nav class="navbar navbar-expand-lg navbar-dark bg-primary fixed-top" id="sideNav">
      <a class="navbar-brand js-scroll-trigger" href="#page-top">
          <span class="d-block d-lg-none">Nicholas Michaud</span>
      </a>
      <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarResponsive"
          aria-controls="navbarResponsive" aria-expanded="false" aria-label="Toggle navigation"><span
              class="navbar-toggler-icon"></span></button>
      <div class="collapse navbar-collapse" id="navbarResponsive">
          <ul class="navbar-nav">
              <li class="nav-item"><a class="nav-link js-scroll-trigger" href="index.html">Nicholas Michaud</a></li>
              <br> 
              <li class="nav-item"><a class="nav-link js-scroll-trigger" href="index.html#about">About</a></li>
              <li class="nav-item"><a class="nav-link js-scroll-trigger" href="index.html#experience">Experience</a></li>
              <li class="nav-item"><a class="nav-link js-scroll-trigger" href="index.html#education">Education</a></li>
              <li class="nav-item"><a class="nav-link js-scroll-trigger" href="index.html#interests">Projects</a></li>
          </ul>
      </div>
  </nav>
  <!-- Page Content-->  <section class="resume-section" id="about">
            <div class="resume-section-content">
              <h2 class="mb-0">
                  Common Search Algorithms Applied to Mazes
              </h2>
              <br>
              <p> A 20x20 maze generated using Prim's minimum spanning tree algorithm navigated by a series of common search
                algorithms to help visualize how each algorithm finds the solution. Maze and navigation written in d3.js and
                everything else in vanilla. Every time you click run a new random maze is formed.
                
                <br><br>Use the drop down to try each algorithm!
              </p>
                 

            
  <select id="methodSelect">
    <option value="">Select an Algorithm</option>
    <option value="breadthfirst">Breadth First</option>
    <option value="depthfirst">Depth First</option>
    <option value="methodThree">Method Three</option>
</select>
              <button class id="runMethodButton"  type="button" >Run</button>
                  
     
                  
               
      
             
          <script>

document.addEventListener("DOMContentLoaded", function() {
    const selectElement = document.getElementById("methodSelect");
    const buttonElement = document.getElementById("runMethodButton");
    let selectedMethod = '';

    selectElement.addEventListener("change", function(event) {
        
        selectedMethod= event.target.value
        console.log(selectedMethod)
    
    });
    buttonElement.addEventListener("click", function() {
      console.log(selectedMethod)
      if(selectedMethod == "breadthfirst"){
        draw_maze("bfs")
      } 
      if(selectedMethod == "depthfirst"){
        draw_maze("dfs")
      }   
    
    });
});
          </script>
     

    
    
             
    
     
                <script src="mazes.js"></script>
                

                <script type="module">
                
                    import * as d3 from "https://cdn.jsdelivr.net/npm/d3@7/+esm";
                    svg = d3
.selectAll("body")
.append("svg")
.attr("width", 700).attr("height", 600)
                    var svg = d3.select("svg")



let test_array = [
[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
[0, 0, true, 0, true, true, true, 0, true, 0, true, 0],
[0, 0, true, 0, true, 0, true, 0, true, 0, true, 0],
[0, 0, true, true, true, true, true, true, true, true, true, 0],
[0, 0, true, 0, true, 0, true, 0, true, 0, true, 0],
[0, 0, true, 0, true, 0, true, 0, true, 0, true, 0],
[0, 0, true, 0, true, 0, true, 0, true, 0, true, 0],
[0, 0, true, true, true, true, true, 0, true, 0, true, 0],
[0, 0, true, 0, true, 0, true, 0, true, 0, true, 0],
[0, 0, true, true, true, 0, true, 0, true, true, true, 0],
[0, 0, 0, 0, 0, 0, 0, 0, 0, true, 0, 0],
[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]


                    function createGraphFrom2DArray(array){
    const graph = new Map();
    //DETELETE
    array= test_array
    const rows = array.length;
    const cols = array[0].length;
      
  //  console.log(array)



    function addEdge(node1, node2){
        
        if(!graph.has(node1)&& array[node1[0]][node1[2]]){
         // console.log("NODE1: "+node1)
            graph.set(node1,[])
        }
        if(!graph.has(node2)&& array[node2[0]][node2[2]]){
            graph.set(node2,[])
        }
        if(graph.has(node1)){
            graph.get(node1).push(node2)
        }
        if(graph.has(node2)){
            graph.get(node2).push(node1)
        }
      
    }
    for(let i =0;i<rows;i++){
        for(let j = 0; j< cols; j++){
         // console.log(i+","+j)
            if(array[i][j]){
             // console.log("PASSED: "+i+","+j)
    
                const node = `${i},${j}`;

                for (const [di, dj] of [[-1, 0], [1, 0], [0, -1], [0, 1]]) {
                    const ni = i + di;
                    const nj = j + dj;
                    if (ni >= 0 && ni < rows && nj >= 0 && nj < cols && array[ni][nj]) {
                        const neighbor = `${ni},${nj}`;
                        //console.log('neighbor passed: '+ neighbor)
                        addEdge(node, neighbor);
                    }
                }
            }
        }
    }
   // console.log(graph)
return graph;
}





 
  function draw_maze(){

let svg_width = 700
let svg_height = 600
svg.remove();
svg = d3
.selectAll("body")
.append("svg")
.attr("width", 700).attr("height", 600)
let maze = make_maze()

}

        
             


class Maze {
  constructor(){
    this.svg_width = 700
    this.svg_height = 600
    this.maze_array = this.borders(generate_maze(20, 20))
    this.maze_width = this.maze_array[0].length
    this.maze_height = this.maze_array.length
    this.width = (this.svg_width / (this.maze_width)) * .98
    this.height = this.svg_height / (this.maze_height) * .98
    this.start = this.get_start()
    this.end = this.get_end()

  }

 search_animation(x,y) {
    return new Promise(resolve => {
      setTimeout(() => {
        const path2 = d3.path()
        path2.rect(this.width * y, this.height * x, this.width, this.height);
        path2.closePath()
        svg.append('path')
          .attr('d', path2)
          .attr('fill', 'grey')


        const path = svg.append('path')
          .attr('d', path2)
          .attr('fill', 'grey');
        resolve()
      }, 1)

    })

  }
  get_start() {
    for (let x = 0; x <  this.maze_width; x++) {
      let random = Math.floor(Math.random() * this.maze_width)
      if (this.maze_array[1][random] == true) {
        return random
      }
      else if (x == this.maze_width-2) {
        while (this.maze_array[2][random] != true) {
          random = Math.floor(Math.random() * this.maze_width)
        }
        this.maze_array[1][random] = true
        return random
      }

    }

  }
  get_end() {
    for (let x = 0; x < this.maze_width; x++) {
      let random = Math.floor(Math.random() * this.maze_width)
      if (this.maze_array[this.maze_height - 2][random] == true) {
        return random
      }
      else if (x == this.maze_width -2) {
        while (this.maze_array[this.maze_height - 3][random] != true) {
          random = Math.floor(Math.random() * this.maze_width)
        }
        this.maze_array[this.maze_height - 2][random] = true
        return random
      }

    }

  }
polygons(x, y, position_x) {


if (this.maze_array[x][y] != true) {
  const path = d3.path()
  path.rect(position_x, this.height * x, this.width, this.height);
  path.closePath()
  svg.append('path')
    .attr('d', path)
    .attr('fill', 'black')


}
if (this.maze_array[x][y] == true) {
  const path = d3.path()
  path.rect(position_x, this.height * x, this.width, this.height);
  path.closePath()
  svg.append('path')
    .attr('d', path)
    .attr('fill', 'white')


}

if (x == this.maze_height - 1 && y == this.end) {
  const path = d3.path()
  path.rect(position_x, this.height * x, this.width, this.height);
  path.closePath()
  svg.append('path')
    .attr('d', path)
    .attr('fill', 'green')


}


if (x == 0 && y == this.start) {
  const path = d3.path()
  path.rect(position_x, this.height * x, this.width, this.height);
  path.closePath()
  svg.append('path')
    .attr('d', path)
    .attr('fill', 'red')


}


}
borders(maze){
  let maze_length = maze.length
  for(let x=0; x< maze_length;x++){

    //MIGHT NOT MAKE FULL SQUARE
   // if( maze[x][maze[x].length-1] != 0){
      maze[x].push(0)
   // }
      

   maze[x].unshift(0)

  }
  let horizontal_border =  Array.apply(null, Array(maze[0].length))
  .map(function () {return 0; })
  maze.unshift(horizontal_border)
  maze.push(horizontal_border)

 return maze

  }

print_maze(){
  console.log(this.maze_array)
  console.log(this.maze_height)
}

async bfs(graph,start,end,width,height){
    let array_length = graph.length
    const queue = [[0,this.start]];
    const visited = new Set()
    const results = []
   // console.log(queue)
    while(queue.length){
    //  console.log(queue)
      let vertex = queue.shift()
     
        if(!visited.has(JSON.stringify(vertex))){
        //  console.log(visited)
            visited.add(JSON.stringify(vertex))
            results.push(vertex)
         await  this.search_animation(vertex[0],vertex[1])
  
           
        }
         let x = vertex[0]
         let y = vertex[1]
      //  console.log(vertex)
     //   console.log(graph)
     
     if(vertex[0] == array_length-2 && vertex[1]==end){
          console.log("found!")

          break;
        }
        let next = []
        if(this.maze_array[x+1][y] && x < this.maze_array.length){
          console.log('true: '+x)
          next.push([x+1,y])
        }
        if(this.maze_array[x][y+1] && y < this.maze_array[0].length){
          next.push([x,y+1])
        }
        if( x >0 && this.maze_array[x-1][y]){
          next.push([x-1,y])
        }
        if( y >0 && this.maze_array[x][y-1]){
          next.push([x,y-1])
        }
        //console.log(next)
        //let graph_iter = graph.get(vertex)
       //console.log(graph_iter)

        if (next){
        for (let neighbor of next){
               
          if(!visited.has((JSON.stringify(neighbor))) && !queue.includes(neighbor)){

            queue.push(neighbor)

          }
            
        }
      }
    }
    return results

    

}
async dfs(graph,start,end,width,height){
    let array_length = graph.length
    const queue = [[0,this.start]];
    const visited = new Set()
    const results = []
   // console.log(queue)
    while(queue.length){
    //  console.log(queue)
      let vertex = queue.pop()
     
        if(!visited.has(JSON.stringify(vertex))){
        //  console.log(visited)
            visited.add(JSON.stringify(vertex))
            results.push(vertex)
         await  this.search_animation(vertex[0],vertex[1])
  
           
        }
         let x = vertex[0]
         let y = vertex[1]
      //  console.log(vertex)
     //   console.log(graph)
     
     if(vertex[0] == array_length-2 && vertex[1]==end){
          console.log("found!")

          break;
        }
        let next = []
        if(this.maze_array[x+1][y] && x < this.maze_array.length){
          console.log('true: '+x)
          next.push([x+1,y])
        }
        if(this.maze_array[x][y+1] && y < this.maze_array[0].length){
          next.push([x,y+1])
        }
        if( x >0 && this.maze_array[x-1][y]){
          next.push([x-1,y])
        }
        if( y >0 && this.maze_array[x][y-1]){
          next.push([x,y-1])
        }
        //console.log(next)
        //let graph_iter = graph.get(vertex)
       //console.log(graph_iter)

        if (next){
        for (let neighbor of next){
               
          if(!visited.has((JSON.stringify(neighbor))) && !queue.includes(neighbor)){

            queue.push(neighbor)

          }
            
        }
      }
    }
    return results

    

}




make_maze(type) {
  
    for (let x = 0; x < this.maze_height; x++) {
      for (let y = 0; y < this.maze_array[x].length; y++) {
        this.polygons( x, y, (this.width * y))
      }
    }
    if(type == "bfs"){
      this.bfs(this.maze_array,this.start,this.end,this.width,this.height)
    }
    if(type == "dfs"){
      this.dfs(this.maze_array,this.start,this.end,this.width,this.height)
    }

    

  }
}
function maze_maker(type) {

      let maze = new Maze();  // Create a new Maze instance
      maze.make_maze(type);  // Draw the maze
    }


window.draw_maze = maze_maker;





















</script>
</body>

</html>